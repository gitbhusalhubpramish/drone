#include <Wire.h>
#include <MPU6050.h>
#include <Servo.h>

// ===== DRONE MOTOR LAYOUT =====
// m1 - Front Left
// m2 - Front Right
// m3 - Back Left
// m4 - Back Right

#define lsig 2
#define rsig 4
#define fsig 7
#define bsig 8

Servo m1, m2, m3, m4;
const int dm1 = 9;
const int dm2 = 10;
const int dm3 = 11;
const int dm4 = 6;

// ===== MPU VARIABLES =====
MPU6050 mpu;
float pitch = 0, roll = 0;         // Filtered angles
float gyroPitch = 0, gyroRoll = 0; // Gyro integrated angles
float Kp = 2.0;                    // Proportional gain for correction
unsigned long lastTime = 0;

// ===== BUTTON STATES =====
int rbtn, lbtn, fbtn, bbtn;
bool rclk = false, lclk = false, fclk = false, bclk = false;

// ===== SPEEDS =====
int hi = 2000, lo = 1000, mid = 1500;

void setup() {
  Serial.begin(9600);
  Wire.begin();

  mpu.initialize();
  if (!mpu.testConnection()) {
    Serial.println("MPU6050 connection failed!");
    while (1);
  }
  Serial.println("MPU6050 ready.");

  m1.attach(dm1);
  m2.attach(dm2);
  m3.attach(dm3);
  m4.attach(dm4);

  pinMode(lsig, INPUT);
  pinMode(rsig, INPUT);
  pinMode(fsig, INPUT);
  pinMode(bsig, INPUT);

  // Arm ESCs
  m1.writeMicroseconds(1000);
  m2.writeMicroseconds(1000);
  m3.writeMicroseconds(1000);
  m4.writeMicroseconds(1000);
  delay(2000);

  lastTime = micros();
}

void loop() {
  // ===== TIME STEP =====
  unsigned long now = micros();
  float dt = (now - lastTime) / 1000000.0;
  lastTime = now;

  // ===== BUTTON READ =====
  rbtn = pulseIn(rsig, HIGH);
  lbtn = pulseIn(lsig, HIGH);
  bbtn = pulseIn(bsig, HIGH);
  fbtn = pulseIn(fsig, HIGH);

  rclk = rbtn > 1700;
  lclk = lbtn > 1700;
  fclk = fbtn > 1700;
  bclk = bbtn > 1700;

  // ===== MPU READ =====
  int16_t ax, ay, az, gx, gy, gz;
  mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

  // Accelerometer tilt (degrees)
  float accPitch = atan2(ax, sqrt(ay * ay + az * az)) * 180 / PI;
  float accRoll  = atan2(ay, sqrt(ax * ax + az * az)) * 180 / PI;

  // Gyroscope rates (deg/sec) — 131 LSB/(°/s)
  float gyroRateX = gx / 131.0; // Roll rate
  float gyroRateY = gy / 131.0; // Pitch rate

  // Integrate gyro (maintain sign convention from first code)
  gyroPitch += gyroRateY * dt;
  gyroRoll  -= gyroRateX * dt;

  // Complementary filter — merge gyro + accel
  pitch = 0.98 * gyroPitch + 0.02 * accPitch;
  roll  = 0.98 * gyroRoll  + 0.02 * accRoll;

  // ===== BASE SPEEDS =====
  int base1 = mid, base2 = mid, base3 = mid, base4 = mid;

  if (rclk && lclk) {
    base1 = base2 = base3 = base4 = lo; // down
  } 
  else if (fclk && bclk) {
    base1 = base2 = base3 = base4 = hi; // up
  } 
  else if (fclk && rclk) { // rotate CW
    base1 = base3 = mid;
    base2 = base4 = lo;
  } 
  else if (bclk && lclk) { // rotate CCW
    base1 = base3 = lo;
    base2 = base4 = mid;
  } 
  else if (rclk) { // rightward
    base2 = base4 = lo;
    base1 = base3 = mid;
  } 
  else if (lclk) { // leftward
    base1 = base3 = lo;
    base2 = base4 = mid;
  } 
  else if (fclk) { // forward
    base1 = base2 = lo;
    base3 = base4 = mid;
  } 
  else if (bclk) { // backward
    base1 = base2 = mid;
    base3 = base4 = lo;
  }

  // ===== CORRECTIONS =====
  int pitchCorrection = Kp * pitch;
  int rollCorrection  = Kp * roll;

  int sp1 = base1 - pitchCorrection + rollCorrection; // Front-left
  int sp2 = base2 - pitchCorrection - rollCorrection; // Front-right
  int sp3 = base3 + pitchCorrection + rollCorrection; // Back-left
  int sp4 = base4 + pitchCorrection - rollCorrection; // Back-right

  // Limit range
  sp1 = constrain(sp1, 1000, 2000);
  sp2 = constrain(sp2, 1000, 2000);
  sp3 = constrain(sp3, 1000, 2000);
  sp4 = constrain(sp4, 1000, 2000);

  // Send to motors
  m1.writeMicroseconds(sp1);
  m2.writeMicroseconds(sp2);
  m3.writeMicroseconds(sp3);
  m4.writeMicroseconds(sp4);

  // Debug output
  Serial.print("Pitch: "); Serial.print(pitch);
  Serial.print(" | Roll: "); Serial.print(roll);
  Serial.print(" | Motors: ");
  Serial.print(sp1); Serial.print(", ");
  Serial.print(sp2); Serial.print(", ");
  Serial.print(sp3); Serial.print(", ");
  Serial.println(sp4);

  delay(5); // Faster loop for better stability
}
