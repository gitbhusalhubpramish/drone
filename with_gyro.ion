#include <Wire.h>
#include <MPU6050.h>
#include <Servo.h>

// ===== MOTOR LAYOUT =====
// m1 - Front Left
// m2 - Front Right
// m3 - Back Left
// m4 - Back Right

#define lsig 2
#define rsig 4
#define fsig 7
#define bsig 8

Servo m1, m2, m3, m4;
const int dm1 = 9;
const int dm2 = 10;
const int dm3 = 11;
const int dm4 = 6;

// ===== GYRO VARIABLES =====
MPU6050 mpu;
float pitch = 0, roll = 0;
float gyroPitch = 0, gyroRoll = 0;
float Kp = 2.0; // proportional gain
unsigned long lastTime = 0;

// ===== BUTTON STATE =====
int rbtn, lbtn, fbtn, bbtn;
bool rclk = false, lclk = false, fclk = false, bclk = false;

// ===== BASE SPEEDS =====
int hi = 2000;
int lo = 1000;
int mid = 1500;

void setup() {
  Serial.begin(9600);
  Wire.begin();

  mpu.initialize();
  if (!mpu.testConnection()) {
    Serial.println("MPU6050 connection failed!");
    while (1);
  }
  Serial.println("MPU6050 ready.");

  m1.attach(dm1);
  m2.attach(dm2);
  m3.attach(dm3);
  m4.attach(dm4);

  pinMode(lsig, INPUT);
  pinMode(rsig, INPUT);
  pinMode(fsig, INPUT);
  pinMode(bsig, INPUT);

  // Arm ESCs
  m1.writeMicroseconds(1000);
  m2.writeMicroseconds(1000);
  m3.writeMicroseconds(1000);
  m4.writeMicroseconds(1000);
  delay(2000);

  lastTime = micros();
}

void loop() {
  // ===== TIME STEP =====
  unsigned long now = micros();
  float dt = (now - lastTime) / 1000000.0; // seconds
  lastTime = now;

  // ===== READ BUTTONS =====
  rbtn = pulseIn(rsig, HIGH);
  lbtn = pulseIn(lsig, HIGH);
  bbtn = pulseIn(bsig, HIGH);
  fbtn = pulseIn(fsig, HIGH);

  rclk = rbtn > 1700;
  lclk = lbtn > 1700;
  fclk = fbtn > 1700;
  bclk = bbtn > 1700;

  // ===== READ ACCEL + GYRO =====
  int16_t ax, ay, az, gx, gy, gz;
  mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

  // Accelerometer tilt (degrees)
  float accPitch = atan2(ax, sqrt(ay * ay + az * az)) * 180 / PI;
  float accRoll  = atan2(ay, sqrt(ax * ax + az * az)) * 180 / PI;

  // Gyroscope rates (deg/sec) — default 131 LSB/(°/s)
  float gyroRateX = gx / 131.0;
  float gyroRateY = gy / 131.0;

  // Integrate gyro
  gyroPitch += gyroRateX * dt;
  gyroRoll  += gyroRateY * dt;

  // Complementary filter — merge gyro + accel
  pitch = 0.98 * gyroPitch + 0.02 * accPitch;
  roll  = 0.98 * gyroRoll  + 0.02 * accRoll;

  // ===== MANUAL BASE SPEED =====
  int base1 = mid, base2 = mid, base3 = mid, base4 = mid;

  if (rclk && lclk) {
    base1 = base2 = base3 = base4 = lo; // down
  } 
  else if (fclk && bclk) {
    base1 = base2 = base3 = base4 = hi; // up
  } 
  else if (fclk && rclk) { // rotate CW
    base1 = base3 = mid;
    base2 = base4 = lo;
  } 
  else if (bclk && lclk) { // rotate CCW
    base1 = base3 = lo;
    base2 = base4 = mid;
  } 
  else if (rclk) { // rightward
    base2 = base4 = lo;
    base1 = base3 = mid;
  } 
  else if (lclk) { // leftward
    base1 = base3 = lo;
    base2 = base4 = mid;
  } 
  else if (fclk) { // forward
    base1 = base2 = lo;
    base3 = base4 = mid;
  } 
  else if (bclk) { // backward
    base1 = base2 = mid;
    base3 = base4 = lo;
  }

  // ===== ADD GYRO CORRECTIONS =====
  int pitchCorrection = Kp * pitch;
  int rollCorrection  = Kp * roll;

  int sp1 = base1 - pitchCorrection + rollCorrection; // front-left
  int sp2 = base2 - pitchCorrection - rollCorrection; // front-right
  int sp3 = base3 + pitchCorrection + rollCorrection; // back-left
  int sp4 = base4 + pitchCorrection - rollCorrection; // back-right

  // ===== LIMIT VALUES (1000-2000) =====
  sp1 = constrain(sp1, 1000, 2000);
  sp2 = constrain(sp2, 1000, 2000);
  sp3 = constrain(sp3, 1000, 2000);
  sp4 = constrain(sp4, 1000, 2000);

  // ===== SEND TO MOTORS =====
  m1.writeMicroseconds(sp1);
  m2.writeMicroseconds(sp2);
  m3.writeMicroseconds(sp3);
  m4.writeMicroseconds(sp4);

  // Debug
  Serial.print("Pitch: "); Serial.print(pitch);
  Serial.print(" | Roll: "); Serial.print(roll);
  Serial.print(" | Motors: ");
  Serial.print(sp1); Serial.print(", ");
  Serial.print(sp2); Serial.print(", ");
  Serial.print(sp3); Serial.print(", ");
  Serial.println(sp4);

  delay(5);
}
