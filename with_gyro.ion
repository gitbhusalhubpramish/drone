#include <Wire.h>
#include <MPU6050.h>
#include <Servo.h>

// ===== DRONE MOTOR LAYOUT =====
// m1 - Front Left  (CW)
// m2 - Front Right (CCW)
// m3 - Back Left   (CCW)
// m4 - Back Right  (CW)

#define lsig 2
#define rsig 4
#define fsig 7
#define bsig 8

Servo m1, m2, m3, m4;
const int dm1 = 9;
const int dm2 = 10;
const int dm3 = 11;
const int dm4 = 6;

// ===== MPU VARIABLES =====
MPU6050 mpu;
float pitch = 0, roll = 0, yawRate = 0;
unsigned long lastTime = 0;

// ===== PID VARIABLES =====
float pitchError, rollError, yawError;
float iPitch = 0, iRoll = 0, iYaw = 0;
float lastPitchError = 0, lastRollError = 0, lastYawError = 0;

float Kp = 3.0, Ki = 0.01, Kd = 20.0;     // Pitch/Roll gains
float Kp_yaw = 4.0, Ki_yaw = 0.02, Kd_yaw = 10.0; // Yaw gains

// ===== RC INPUTS =====
volatile uint16_t rcValue[4] = {1500, 1500, 1500, 1500};
volatile uint32_t rcStart[4];
const uint8_t rcPins[4] = {rsig, lsig, fsig, bsig};

// ===== SPEEDS =====
int hi = 2000, lo = 1000, mid = 1500;

// ===== INTERRUPT HANDLER =====
void rcISR0() {
  if (digitalRead(rsig)) rcStart[0] = micros();
  else rcValue[0] = micros() - rcStart[0];
}
void rcISR1() {
  if (digitalRead(lsig)) rcStart[1] = micros();
  else rcValue[1] = micros() - rcStart[1];
}
void rcISR2() {
  if (digitalRead(fsig)) rcStart[2] = micros();
  else rcValue[2] = micros() - rcStart[2];
}
void rcISR3() {
  if (digitalRead(bsig)) rcStart[3] = micros();
  else rcValue[3] = micros() - rcStart[3];
}

void setup() {
  Serial.begin(115200);
  Wire.begin();

  mpu.initialize();
  if (!mpu.testConnection()) {
    while (1);
  }

  m1.attach(dm1);
  m2.attach(dm2);
  m3.attach(dm3);
  m4.attach(dm4);

  // Arm ESCs
  m1.writeMicroseconds(1000);
  m2.writeMicroseconds(1000);
  m3.writeMicroseconds(1000);
  m4.writeMicroseconds(1000);
  delay(2000);

  // Attach interrupts for RC
  attachInterrupt(digitalPinToInterrupt(rsig), rcISR0, CHANGE);
  attachInterrupt(digitalPinToInterrupt(lsig), rcISR1, CHANGE);
  attachInterrupt(digitalPinToInterrupt(fsig), rcISR2, CHANGE);
  attachInterrupt(digitalPinToInterrupt(bsig), rcISR3, CHANGE);

  lastTime = micros();
}

void loop() {
  // ===== TIMING =====
  unsigned long now = micros();
  if (now - lastTime < 4000) return;  // run at ~250 Hz
  float dt = (now - lastTime) / 1000000.0;
  lastTime = now;

  // ===== READ MPU =====
  int16_t ax, ay, az, gx, gy, gz;
  mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

  float accPitch = atan2(ax, sqrt(ay * ay + az * az)) * 180 / PI;
  float accRoll  = atan2(ay, sqrt(ax * ax + az * az)) * 180 / PI;

  float gyroRateX = gx / 131.0;
  float gyroRateY = gy / 131.0;
  yawRate = gz / 131.0;

  static float gyroPitch = 0, gyroRoll = 0;
  gyroPitch += gyroRateY * dt;
  gyroRoll  -= gyroRateX * dt;

  pitch = 0.98 * gyroPitch + 0.02 * accPitch;
  roll  = 0.98 * gyroRoll  + 0.02 * accRoll;

  // ===== RC TARGETS =====
  float targetPitch = (rcValue[2] - 1500) / 500.0 * 15;   // forward/back
  float targetRoll  = (rcValue[0] - 1500) / 500.0 * 15;   // left/right
  float targetYawRate = (rcValue[1] - 1500) / 500.0 * 100; // deg/s
  int thrust = map(rcValue[3], 1000, 2000, 1000, 2000);   // throttle

  // ===== PID CONTROL =====
  // Pitch
  pitchError = targetPitch - pitch;
  iPitch += pitchError * dt;
  float dPitch = (pitchError - lastPitchError) / dt;
  float pitchCorrection = Kp * pitchError + Ki * iPitch + Kd * dPitch;
  lastPitchError = pitchError;

  // Roll
  rollError = targetRoll - roll;
  iRoll += rollError * dt;
  float dRoll = (rollError - lastRollError) / dt;
  float rollCorrection = Kp * rollError + Ki * iRoll + Kd * dRoll;
  lastRollError = rollError;

  // Yaw
  yawError = targetYawRate - yawRate;
  iYaw += yawError * dt;
  float dYaw = (yawError - lastYawError) / dt;
  float yawCorrection = Kp_yaw * yawError + Ki_yaw * iYaw + Kd_yaw * dYaw;
  lastYawError = yawError;

  // ===== MOTOR MIXING =====
  int sp1 = constrain(thrust - pitchCorrection + rollCorrection - yawCorrection, 1000, 2000); // FL (CW)
  int sp2 = constrain(thrust - pitchCorrection - rollCorrection + yawCorrection, 1000, 2000); // FR (CCW)
  int sp3 = constrain(thrust + pitchCorrection + rollCorrection + yawCorrection, 1000, 2000); // BL (CCW)
  int sp4 = constrain(thrust + pitchCorrection - rollCorrection - yawCorrection, 1000, 2000); // BR (CW)

  // ===== SEND TO MOTORS =====
  m1.writeMicroseconds(sp1);
  m2.writeMicroseconds(sp2);
  m3.writeMicroseconds(sp3);
  m4.writeMicroseconds(sp4);

  // Debug
  // Serial.print("Pitch: "); Serial.print(pitch);
  // Serial.print(" Roll: "); Serial.print(roll);
  // Serial.print(" Thrust: "); Serial.print(thrust);
  // Serial.print(" sp1: "); Serial.print(sp1);
  // Serial.print(" sp2: "); Serial.print(sp2);
  // Serial.print(" sp3: "); Serial.print(sp3);
  // Serial.print(" sp4: "); Serial.println(sp4);
}
