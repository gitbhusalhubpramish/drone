#include <Wire.h>
#include <MPU6050.h>
#include <Servo.h>

// ===== DRONE MOTOR LAYOUT =====
// m1 - Front Left (CW)
// m2 - Front Right (CCW)
// m3 - Back Left (CCW)
// m4 - Back Right (CW)

#define lsig 2
#define rsig 4
#define fsig 7
#define bsig 8

Servo m1, m2, m3, m4;
const int dm1 = 9;
const int dm2 = 10;
const int dm3 = 11;
const int dm4 = 6;

// ===== MPU VARIABLES =====
MPU6050 mpu;
float pitch = 0, roll = 0;
float gyroPitch = 0, gyroRoll = 0;
float Kp = 2.0;
unsigned long lastTime = 0;

// ===== RC INPUTS =====
volatile uint16_t rcValue[4] = {1500, 1500, 1500, 1500};
volatile uint32_t rcStart[4];
const uint8_t rcPins[4] = {rsig, lsig, fsig, bsig};

// ===== SPEEDS =====
int hi = 2000, lo = 1000, mid = 1500;

// ===== INTERRUPT HANDLER =====
void rcISR0() {
  if (digitalRead(rsig))
    rcStart[0] = micros();
  else
    rcValue[0] = micros() - rcStart[0];
}
void rcISR1() {
  if (digitalRead(lsig))
    rcStart[1] = micros();
  else
    rcValue[1] = micros() - rcStart[1];
}
void rcISR2() {
  if (digitalRead(fsig))
    rcStart[2] = micros();
  else
    rcValue[2] = micros() - rcStart[2];
}
void rcISR3() {
  if (digitalRead(bsig))
    rcStart[3] = micros();
  else
    rcValue[3] = micros() - rcStart[3];
}

void setup() {
  Serial.begin(115200);
  Wire.begin();

  mpu.initialize();
  if (!mpu.testConnection()) {
    while (1);
  }

  m1.attach(dm1);
  m2.attach(dm2);
  m3.attach(dm3);
  m4.attach(dm4);

  // Arm ESCs
  m1.write(1000);
  m2.write(1000);
  m3.write(1000);
  m4.write(1000);
  delay(2000);

  // Attach interrupts for RC
  attachInterrupt(digitalPinToInterrupt(rsig), rcISR0, CHANGE);
  attachInterrupt(digitalPinToInterrupt(lsig), rcISR1, CHANGE);
  attachInterrupt(digitalPinToInterrupt(fsig), rcISR2, CHANGE);
  attachInterrupt(digitalPinToInterrupt(bsig), rcISR3, CHANGE);

  lastTime = micros();
}

void loop() {
  // ===== TIME STEP =====
  unsigned long now = micros();
  float dt = (now - lastTime) / 1000000.0;
  lastTime = now;

  // ===== RC BUTTON STATES =====
  bool rclk = rcValue[0] > 1700;
  bool lclk = rcValue[1] > 1700;
  bool fclk = rcValue[2] > 1700;
  bool bclk = rcValue[3] > 1700;

  // ===== MPU READ =====
  int16_t ax, ay, az, gx, gy, gz;
  mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

  float accPitch = atan2(ax, sqrt(ay * ay + az * az)) * 180 / PI;
  float accRoll  = atan2(ay, sqrt(ax * ax + az * az)) * 180 / PI;

  float gyroRateX = gx / 131.0;
  float gyroRateY = gy / 131.0;

  gyroPitch += gyroRateY * dt;
  gyroRoll  -= gyroRateX * dt;

  pitch = 0.98 * gyroPitch + 0.02 * accPitch;
  roll  = 0.98 * gyroRoll  + 0.02 * accRoll;

  // ===== MOVEMENT PARAMETERS =====
  // You can tune these for more/less aggressive flight
  float desiredAngle = 15.0;    // degrees for full stick tilt
  int yawAmount = 150;          // motor delta for yaw
  int thrustAmount = 200;       // for up/down

  // ===== TARGET ANGLES =====
  float targetPitch = 0;
  float targetRoll = 0;
  int thrust = 0;
  int yaw = 0;

  // l + r => down
  // f + b => up
  // f + r => yaw CW
  // b + l => yaw CCW
  // f only => forward
  // b only => backward
  // r only => right
  // l only => left

  if (lclk && rclk && !fclk && !bclk) {
    thrust = -thrustAmount;
  } else if (fclk && bclk && !lclk && !rclk) {
    thrust = thrustAmount;
  } else if (fclk && rclk && !bclk && !lclk) {
    yaw = yawAmount; // yaw CW
  } else if (bclk && lclk && !fclk && !rclk) {
    yaw = -yawAmount; // yaw CCW
  } else if (fclk && !bclk && !lclk && !rclk) {
    targetPitch = -desiredAngle; // forward
  } else if (bclk && !fclk && !lclk && !rclk) {
    targetPitch = desiredAngle; // backward
  } else if (rclk && !lclk && !fclk && !bclk) {
    targetRoll = desiredAngle; // right
  } else if (lclk && !rclk && !fclk && !bclk) {
    targetRoll = -desiredAngle; // left
  }
  // else: hover

  // ===== BASE SPEEDS =====
  int base1 = mid + thrust;
  int base2 = mid + thrust;
  int base3 = mid + thrust;
  int base4 = mid + thrust;

  // Yaw mixing (CW: m1, m4; CCW: m2, m3)
  base1 += yaw;
  base4 += yaw;
  base2 -= yaw;
  base3 -= yaw;

  // ===== CORRECTIONS (move to target angles) =====
  int pitchCorrection = Kp * (pitch - targetPitch);
  int rollCorrection  = Kp * (roll - targetRoll);

  int sp1 = constrain(base1 - pitchCorrection + rollCorrection, 1000, 2000); // FL
  int sp2 = constrain(base2 - pitchCorrection - rollCorrection, 1000, 2000); // FR
  int sp3 = constrain(base3 + pitchCorrection + rollCorrection, 1000, 2000); // BL
  int sp4 = constrain(base4 + pitchCorrection - rollCorrection, 1000, 2000); // BR

  // ===== SEND TO MOTORS (50Hz) =====
  static unsigned long lastMotorUpdate = 0;
  if (now - lastMotorUpdate >= 20000) { // every 20 ms
    lastMotorUpdate = now;
    m1.write(sp1);
    m2.write(sp2);
    m3.write(sp3);
    m4.write(sp4);
  }

}
