#include <Wire.h>
#include <MPU6050.h>
#include <Servo.h>

// ===== MOTOR LAYOUT =====
Servo m1, m2, m3, m4;
const int dm1 = 9, dm2 = 10, dm3 = 11, dm4 = 6;

// ===== RC INPUT PINS =====
#define RSIG 2
#define LSIG 4
#define FSIG 7
#define BSIG 8
volatile uint16_t rcValue[4] = {1500,1500,1500,1500};
volatile uint32_t rcStart[4];
const uint8_t rcPins[4] = {RSIG, LSIG, FSIG, BSIG};

// ===== MPU6050 =====
MPU6050 mpu;
float pitch=0, roll=0, gyroPitch=0, gyroRoll=0;
float Kp = 2.0;
unsigned long lastTime=0;

// ===== BATTERY MONITOR =====
const int VBAT_PIN = A0;
const int BUZZ_PIN = 5;
const float R1=100000.0, R2=33000.0;
const float ADC_TO_V = 5.0/1023.0*(R1+R2)/R2;
const float WARN_V=10.5, CRIT_V=9.9;
float vbat_filt=11.1;

// ===== THRUST =====
int hi=2000, lo=1000, mid=1500;
int currentThrust=0;
int thrustStep=2;

// ===== INTERRUPTS =====
void rcISR0(){ rcValue[0] = digitalRead(RSIG) ? (rcStart[0]=micros(), rcValue[0]) : micros()-rcStart[0]; }
void rcISR1(){ rcValue[1] = digitalRead(LSIG) ? (rcStart[1]=micros(), rcValue[1]) : micros()-rcStart[1]; }
void rcISR2(){ rcValue[2] = digitalRead(FSIG) ? (rcStart[2]=micros(), rcValue[2]) : micros()-rcStart[2]; }
void rcISR3(){ rcValue[3] = digitalRead(BSIG) ? (rcStart[3]=micros(), rcValue[3]) : micros()-rcStart[3]; }

// ===== BATTERY FUNCTIONS =====
float getBatteryVoltage() {
    long acc=0;
    for(int i=0;i<8;i++) acc+=analogRead(VBAT_PIN);
    float v=acc/8.0*ADC_TO_V;
    vbat_filt = 0.9*vbat_filt + 0.1*v;
    return vbat_filt;
}

float batteryThrottleScale() {
    float v = getBatteryVoltage();
    static unsigned long t0=0;
    unsigned long t=millis();
    bool buzz=false;
    if(v<=CRIT_V) buzz=true;
    else if(v<=WARN_V) buzz=((t/300)%2)==0;
    digitalWrite(BUZZ_PIN, buzz?HIGH:LOW);
    if(v>=WARN_V) return 1.0;
    if(v<=CRIT_V) return 0.6;
    return 0.6 + 0.4*(v-CRIT_V)/(WARN_V-CRIT_V);
}

// ===== SETUP =====
void setup() {
    Serial.begin(115200);
    Wire.begin();
    mpu.initialize();
    if(!mpu.testConnection()) while(1);

    m1.attach(dm1); m2.attach(dm2); m3.attach(dm3); m4.attach(dm4);

    // Arm ESCs
    m1.write(1000); m2.write(1000); m3.write(1000); m4.write(1000);
    delay(2000);

    // RC interrupts
    attachInterrupt(digitalPinToInterrupt(RSIG), rcISR0, CHANGE);
    attachInterrupt(digitalPinToInterrupt(LSIG), rcISR1, CHANGE);
    attachInterrupt(digitalPinToInterrupt(FSIG), rcISR2, CHANGE);
    attachInterrupt(digitalPinToInterrupt(BSIG), rcISR3, CHANGE);

    pinMode(VBAT_PIN, INPUT);
    pinMode(BUZZ_PIN, OUTPUT);
    digitalWrite(BUZZ_PIN, LOW);

    // MPU accel Z calibration
    float azsum=0;
    int16_t ax, ay, az, gx, gy, gz;
    for(int i=0;i<400;i++){
        mpu.getMotion6(&ax,&ay,&az,&gx,&gy,&gz);
        azsum += (float)az;
        delay(5);
    }
    accZ_offset = azsum/400;
    lastTime=micros();
}

// ===== LOOP =====
void loop() {
    unsigned long now=micros();
    float dt = (now-lastTime)/1000000.0;
    lastTime=now;

    // RC buttons
    bool rclk = rcValue[0]>1700;
    bool lclk = rcValue[1]>1700;
    bool fclk = rcValue[2]>1700;
    bool bclk = rcValue[3]>1700;

    // MPU read
    int16_t ax, ay, az, gx, gy, gz;
    mpu.getMotion6(&ax,&ay,&az,&gx,&gy,&gz);
    float accPitch = atan2(ax,sqrt(ay*ay+az*az))*180/PI;
    float accRoll  = atan2(ay,sqrt(ax*ax+az*az))*180/PI;
    gyroPitch += gy/131.0*dt;
    gyroRoll  -= gx/131.0*dt;
    pitch = 0.98*gyroPitch + 0.02*accPitch;
    roll  = 0.98*gyroRoll + 0.02*accRoll;

    // Movement logic
    float targetPitch=0, targetRoll=0;
    int targetThrust=0, yaw=0;
    const float desiredAngle=15.0;
    const int yawAmount=150;
    const int maxThrustUp=300, maxThrustDn=-300;

    if(lclk && rclk && !fclk && !bclk) targetThrust=maxThrustDn;
    else if(fclk && bclk && !lclk && !rclk) targetThrust=maxThrustUp;
    else if(fclk && rclk && !bclk && !lclk) yaw=yawAmount;
    else if(bclk && lclk && !fclk && !rclk) yaw=-yawAmount;
    else if(fclk && !bclk && !lclk && !rclk) targetPitch=-desiredAngle;
    else if(bclk && !fclk && !lclk && !rclk) targetPitch=desiredAngle;
    else if(rclk && !lclk && !fclk && !bclk) targetRoll=desiredAngle;
    else if(lclk && !rclk && !fclk && !bclk) targetRoll=-desiredAngle;

    // Thrust ramping
    if(currentThrust<targetThrust) currentThrust+=thrustStep;
    else if(currentThrust>targetThrust) currentThrust-=thrustStep;

    // Battery scaling
    float bScale = batteryThrottleScale();
    int scaledThrust = (int)(currentThrust*bScale);

    // Base motor speeds
    int base1=mid+scaledThrust, base2=mid+scaledThrust, base3=mid+scaledThrust, base4=mid+scaledThrust;
    base1 += yaw; base4 += yaw; base2 -= yaw; base3 -= yaw;

    // Pitch/Roll corrections
    int pitchCorrection = Kp*(pitch-targetPitch);
    int rollCorrection  = Kp*(roll-targetRoll);

    int sp1 = constrain(base1-pitchCorrection+rollCorrection,1000,2000);
    int sp2 = constrain(base2-pitchCorrection-rollCorrection,1000,2000);
    int sp3 = constrain(base3+pitchCorrection+rollCorrection,1000,2000);
    int sp4 = constrain(base4+pitchCorrection-rollCorrection,1000,2000);

    // Update motors every 20ms
    static unsigned long lastMotorUpdate=0;
    if(now-lastMotorUpdate>=20000){
        lastMotorUpdate=now;
        m1.write(sp1); m2.write(sp2); m3.write(sp3); m4.write(sp4);
    }
}
